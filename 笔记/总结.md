*HTML+CSS*
一.a元素
  1.href属性: URL
  2.target属性: _self默认值: 在当前窗口打开URL _blank: 在新窗口打开URL

二.iframe元素
  1.src属性:
  2.frameborder属性: 1显示边框 0不显示边框

三.URL格式:[协议类型]://[服务器地址]:[端口号]/[文件路径][文件名]?[查询]#[片段ID] http://123.123.207.222:80/abc/why/mi.png

四.link元素
  1.href属性: URL
  2.rel属性: icon站点:图标 stylesheet:CSS样式
  
五.文本属性
  1.text-align(对齐): left/right/center/justify
  2.text-decoration: underline下划线/overline上划线/line-through删除线

六.字体属性
  1.font-family: '字体', '备用字体1', '备用字体2'
  2.font-style: italic斜体
  3.font-height(重要): 居中 行高=height
  4.网络字体: 
    @font-face {
      font-family: "hyfont01"
      src: url(地址)
    }
    body {
      font-family: "hyfont01"
    }

七.选择器
  1.通用选择器: *{}
  2.元素选择器: div{}
  3.类选择器: .box{}
  4.id选择器: #{}
  5.属性选择器: [title=值(可以不写)] {} 选中有title的元素 [class=值] {} 选中class
  6.后代选择器: .home span {}(名字为home的div后代中的所有span) .home > span {}(名字为home的div的子代中的span)
  7.兄弟选择器: .box + div(相邻的div) .box ~ div(所有兄弟div)
  8.交集选择器: div.box {}(既是div又叫box)
  9.并集选择器: body, p, h1, h2 {}(都选中)

八.伪类:
  1.div:hover{}
  2.a:link{}
  3.a:visited{}
  4.a:active{}

九.伪元素(使用伪元素要有content:"")
  1.::first-line: 针对首行文本设置属性
  2.::first-letter: 对首字母设置属性
  3.::before: 元素前设置文本和样式
  4.::after: 元素后设置文本和样式

十.继承优先级
  1.!important(在属性值后面加) 10000: color: red !important 
  2.内联样式 1000
  3.id选择器 100
  4.类选择器 10
  5.元素选择器 1
  6.通配选择器 0

十一.display属性
  1.block 块
  2.inline 行内
  3.inline-block 行内块(设置来包裹内容)

十二.HTML元素的四种隐藏方法:
  1.display: none
  2.visibility: hidden
  3.color: rgba(`,`,`,0) 透明度=0
  4.opacity: 0 透明度 

十三.overflow属性
  1.scroll值: 滚动条
  2.auto值: 内容超出元素 有滚动条 没超出 没有滚动条

十四.div
  1.content
  2.padding
  3.boeder
  4.margin
  5.outline
  6.shadow: 5px 5px 10px 10px red (xy偏移量 模糊半径 延伸半径 颜色)

十五.background属性
  1.background-image: url(), url() 层叠
  2.background-repeat: no-repeat 取消平铺/repeat-x 在水平平铺/repeat-y 竖直平铺
  3.background-size: cover 覆盖/100% 100% 宽高百分百拉伸/auto 默认值/contain 缩放图片保持宽高比
  4.background-position: 100px 100px 一左上角为原点设置xy像素距离/top center 设置上下左右中位置
  5.background-attachment: scroll 滚动内容时背景固定/local 滚动内容的时候背景跟着滚动 默认repeat/fixed 相对于浏览器视口固定

十六.列表元素
  1.有序列表: ol-li
  2.无序列表: ul-li
  3.定义列表: dl-dt-dd 默认无序
  4.list-style-type: none 消除列表序号

十七.表格元素
  1.重构代码:
  <table>
  <caption></caption>
  <thead>
    <tr>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td></td>
    </tr>
  </tfoot>
  </table>
  2.添加边框: td {border: 1px solid #333}
  3.边框合并: table {border-collapse: collapse}
  4.选择器: table tbody tr: nth-child(1) {}
  5.单元格合并属性:
  -colspan(跨列合并): 最左边的单元格上colspan属性,并且省略掉合并的td
  <tr>
    <td colspan="2"></td>
  </tr>
  -rowspan(跨行合并): 最上面的单元格上rowspan属性,并且省略掉后面tr中的td
  <tr>
    <td rowspan="2"></td>
  </tr>

十八.表单元素
  1.form: 表单
    -<form action="服务器地址" method="post" target="_blank">
      <div>
        <label for="">
          用户: <input id="" type="" name="">
        </label>
      </div>
      <div>
        <label for="">
          密码: <input id="" type="" name="">
        </label>
      </div>
    </form>
    (所有input/buttom都加name,才能把值传给服务器)
  2.input: 输入框
    -<input type="text"> 显示
    -<input type="password"> 隐藏
    -<input type="data"> 日期
    -<input type="radio"> 圆形按钮
    -<input type="reset" value="重置按钮"> 
    <button type="reset">重置按钮</button>
    -<input type="submit" value="提交按钮">
    <button type="submit">提交按钮</button>
    (input提交值提交的是value)
    -<label for="username">
      用户:
      <input id="username" type="text">
    </label>
    (label可以实现鼠标点击"用户"就可以将光标自动放置在input里)
  3.textarea: 多行文本输入
    -<textarea name="" id="" cols="'列数'" rows="'行数'"></textarea>
  4.select/option: 
    -<select name="" id="">
      <option value="apple">苹果</option>
      <option value="bannana" checked(默认选中)>香蕉</option>
    </select>

十九.结构伪类
  1. :nth-child(1) 是父元素中的第一个子元素: ul > li:nth-child(3){} (找到ul中的第3个li 会被干扰项干扰)
    :nth-child(2n) 选中所有偶数
  2. :nth-last-child() 选中倒数的第几个 
  3. :nth-of-type() 选中父元素中的第几个子元素: .box > div:nth-of-type(3){} (不管干扰项 只找div)
  4. :nth-last-of-type() 选中倒数的第几个 
  5. 其他结构伪类:
    -:first-child
    -:last-child
    -:first-of-type
    -:last-of-type
    -:only-child 是父元素中唯一的子元素
    -:only-of-type 是父元素中唯一的这种类型的子元素
  6. :root{} (根元素:HTML元素)
  7. :empty{} (空的时候设置样式)

二十.光标cursor
  1.default: 由操作系统决定,一般就是一个小箭头
  2.pointer: 一只小手,鼠标指针挪到连接上默认就是这个样式

二十一.定位
  1.relative(相对定位)
    依然在标准流中 相对位置为本元素原来位置的左上角
    不设置position: relative: 会把附近元素挤开
    设置position: relative: 不会把附近元素挤开,可以使用left/top/right/bottom来移动,比如left: 30px; top: 50px
  2.absolute(绝对定位)
    脱离标准流
    可以使用left/right/top/bottom进行定位
    定位参照对象是最邻近的定位祖先元素 如果没有就选择视口
  3.fixed(固定定位)
    脱离标准流
    可以使用left/right/top/bottom进行定位
    定位参照对象是视口 当画布滚动时 固定不动
  4.将position设置为absolute/fixed元素的特点
    可以随意设置宽高
    宽高默认由内容决定(和行内块元素类似)
    不再受标准流的约束(不再严格从上到下从左到右排布)
    不再给父元素汇报宽高
    脱标元素内部默认还是按照标准流布局
    希望绝对定位元素在参照对象中居中显示: left:0 right:0 top:0 bottom:0 margin:auto 另外还得设置具体宽高值
  5.sticky(粘性定位)
    可以看作是相对定位和固定(绝对)定位的结合体
    它允许被定位元素表现得像相对定位一样 直到它滚动到某个阈值点 当它到达这个阈值点时就变成固定(绝对)定位
    语法:
    元素 {
      position: sticky;
      top: 0; (当元素上界碰到视口时 就固定在这个位置)
    }
    sticky是相对于最近的滚动祖先包含滚动视口的(可用overflow: scroll)
  6.z-index:
    用来设置定位元素的层叠顺序(仅对定位元素有效)
    取值: 正数 负数 0

二十二.flex布局
  1.flex-direction 
    决定了 main axis 的方向 有4个取值
    row从左到右/row-reverse反转/column从上到下/column-reverse反转
  2.flex-wrap
    nowrap元素不换行自动压缩/wrap放不下自动换行/wrap-reverse反转
  3.flex-flow
    是flex-direction和flex-wrap的简写 比如 flex-flow: row wrap;
  4.justify-content
    flex-end向右对齐/center居中对齐/space-between两端对齐/space-evenly两端中间一起等分/space-around中间等分两端空间是中间的一半
  5.align-items
    决定了flex items在cross axis上的对齐方式
    center竖直居中对齐/end最底部对齐/baseline与文本基线对齐
  6.align-content
    决定了多行flex items在cross axis上的对齐方式
    space-between水平/items在竖直方向上两端等分对齐/flex-start从上往下对齐
  7.flex-grow(拉伸)
  8.flex-shrink(压缩)
  9.flex-basis

二十三.重置
  1.清除浮动:
  元素::after {
    content: "";
    display: block;
    clear: both;
    height: 0;
    visibility: hidden;
  }
  2.
  .clear_fix {
    *zoom: 1;
  }
  3.清除浏览器样式
  元素 {
    margin: 0;
    padding: 0;
  }
  4.清除超链接样式
  a {
    text-decoration: none;
    color: #333;
  }
  5.清除列表样式
  ul, li {
    list-style: none;
  }

二十四.HTML5语义化元素:
  1.<top> 顶部元素
  2.<header> 头部元素
  3.<nav> 导航元素
  4.<section> 定义文档某个区域的元素
  5.<article> 内容元素
  6.<aside> 侧边栏元素
  7.<footer> 尾部元素

二十五.HTML5新增元素:
  1. video: <vidio src="相对地址(mp4)" controls></video>
  -width height
  -controls: 布尔类型 是否显示控制栏
  -autoplay: 布尔类型 是否自动播放
  -muted: 布尔类型 是否静音播放
  -preload: 预加载
  2. audio: <audio src="相对地址(mp3)" controls autoplay muted></audio>

二十六.TML5自定义属性:
  data-*: 比如 data-name="why" data-age="18"

二十七.CSS函数:
  1. var: 使用css定义的变量
    html {
      <!-- 定义一个变量 -->
      --main-color: #fff;
    }
    .box {
      color: var(--main-color);
    }
  2. calc 计算css值 通常用于计算元素的大小或位置
    width: calc(100% - 60px);
  3. blur: 毛玻璃效果
  4. gradient: 颜色渐变函数

二十八.BFC:
  1. 在哪些情况下会创建BFC
  -根元素
  -浮动元素
  -绝对定位元素
  -弹性元素
  -...
  2. BFC特点
  -在BFC中 box会在垂直方向上一个挨着一个排布
  -垂直方向间距由margin属性决定
  -在同一个BFC中 相邻的两个box之间的margin会折叠
  -在BFC中 每个元素的左边缘是紧挨着包含块的左边缘
  3. BFC作用
  -解决margin的折叠问题
  -解决浮动高度坍塌问题
    要满足两个条件:
    浮动元素的父元素触发BFC 形成独立的块级格式化上下文
    浮动元素的父元素高度是auto
  4. BFC高度是auto的情况下 如何计算高度
  -如果只有inline-block 是行高的顶部和底部的距离
  -如果有block-level 是由最底层的块上边缘和最底层块盒子的下边缘之间的距离
  -如果有绝对定位元素 将被忽略
  -如果有浮动元素 那么会增加高度以包括这些浮动元素的下边缘

二十九.媒体查询的三种方法
  1.
  @import url(改变样式相对路径) (max-width: 800px);
  2.
  <link rel=stylesheet" media="(max-width: 800px)" href="改变样式相对路径">
  3.  
  @media (min-width: 320px) {
    .box {font-size: 15px;}
  }
  @media (min-width: 375px) {
    .box {font-size: 18px;}
  }
  @media (min-width: 414px) {
    .box {font-size: 21px;}
  }
  @media (min-width: 480px) {
    .box {font-size: 24px;}
  }

三十.transform属性
  1.平移: .box {transform: translate(x,y);}
  2.缩放: .box {transform: scale(x,y);}
  3.倾斜: .box {transform: skew(deg,deg);}
  4.旋转: .box {transform: rotate(deg);}
  5.原点: transform-origin: x,y

三十一.动画
  1.transition:
  -transition-property: left; (方向)
  -transition-duration: 1s; (时间)
  -transition-timing-function: easr-in; (轨迹)
  -transition-delay: 2s; (延迟)
  2.animation动画:
  animation-delay: 2s;
  animation-name: moveAnim;
  animation-duration: 3s;
  animation-timing-function: ease-in-out;
  animation-iteration-count: 2; (执行动画次数)
  animation-direction: reverse;
  animation-fill-mode: fowards/backwards (最后停留位置)
  @keyframes moveAnim {
    0% {
      transform: translate(0, 0) scale(0.5, 0.5);
    }
    33% {
      transform: translate(0, 200px) scale(1.2, 1.2);
    }
    66% {
      transform: translate(400px, 200px) scale(1, 1);
    }
    100% {
      transform: translate(400px, 0) scale(0.5, 0.5);
    }
  }

三十二.防止溢出
  .nowrap_ellipsis {
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

三十三.
  水平居中方法总结:
  1.行内级元素:
    设置父元素的 text-align: center
  2.块级元素:
    设置当前块级元素(宽度) margin: 0 auto
  3.绝对定位:
    元素有宽度的情况下 left0 + right0 + marigin:0 auto
  4.flex:
    justify-content: center

  垂直居中:
  1.绝对定位:
    元素有高度情况下 top0 + right0 + marigin:auto 0
    -弊端:脱离标准流+要设置高度
  2.flex:
    -弊端:局部所有元素都要垂直居中
  3.top/translate:
    -让元素向下位移父元素的50%
    -让元素向上唯一自身的50%
    position: relative;
    top: 50%;
    transform: translate(0, -50%);  

三十四.田字布局:
  设置布局视口的宽度: <meta names="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimun-scale=1.0, maximum-scale=1.0">
  <div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
  </div>
  .item {
    width: ;
    height: ;
    margin-top: 1.6vw;
    &:nth-child(2n) {
      margin-left: 1.6vw;
    }
  }

*JS*
一.对象枚举
  var obj = {
    name:"sunwukong",
    age:18,
    gender:"男",
    address:"花果山"
  };
  for(var keys in obj){
    alert("属性名："+keys+"属性值："+obj[keys]);//执行4次
  };

二.this
  1、以函数形式调用 this是window
  2、以方法的形式调用 this是调用方法的对象
  3、以构造函数的形式调用 this是新创建的对象
  4、使用call和apply调用 this是指定的那个对象

三.立即执行函数
  (function(形参){})(实参)

四.数组的方法
  1、push() 方法可向数组的末尾添加元素 并返回新的长度
    arr.push("新值1","新值2","新值N");
    该方法会将数组新的长度返回

  2、pop() 方法可删除数组的最后一个元素
    arr.pop();
    arr.pop();//pop一次删除一个
    该方法会将删除的元素作为返回值返回

  3、unshift() 方法向数组开头添加元素 并返回新的数组长度
    arr.unshift("新值1","新值2","新值N");

  4、shift() 方法可以删除第一个元素 调用一次删一次 返回删除的元素

  5、slice() 从某个已有的数组返回选定的元素
    var = result = arr.slice(start,end);
    console.log(result);
    start和end分别是截取开始位置和结束位置的索引
    如果没有写end 就把后面的全部截取

  6、splice() 删除指定元素 替换元素 插入元素 返回删除元素
    arr.splice(start,end,"替换值");
    start为开始位置的索引 end为删除的数量
    第三个及以后参数 可以传递新元素 这些元素会插入到开始位置的索引前

  7、concat() 可以连接两个或多个数组 并将新的数组返回
    arr.concat(arr2);//连接arr和arr2
    arr.concat(arr2,arr3,"添加新元素")//连接三个数组 再添加新元素

  8、join() 可以将数组转换成字符串
    arr.jion("连接符");//不会对原数组产生影响 而是将转换后的字符串作为结果返回 typeof验证为string
    可以改变连接符 不写的话就是","

  9、reverse() 反转数组

  10、sort() 对数组元素进行排序
    arr.sort();
    会默认按照Unicode编码进行排序

五.数组去重
  //创建一个数组
  var arr = [1,2,3,2,2,1,3,4,2,5];
  //获得数组中的每一个元素
  for(var i=0 ; i<arr.length ; i++){
    //获得当前元素后的元素
    for(var j=i+1 ; j<arr.length ; j++){
      //判断两个元素的值是否相等
      if(arr[i] == arr[j]){
        //如果相等则删除j对应的元素
        arr.splice(j,1);
        //当删除当前的j所在的元素以后 后边的元素会自动补位
        //此时将不会再比较这个元素 所以需要再比较一次j所在位置的元素
        j--;
      }
    }
  }

六.Date对象
  使用Date对象表示时间
  创建对象 会封装成当前代码执行的时间
  var d = new Date();
  alert(d);
  创建一个指定的事件对象
  var d2 = new Date("12/03/2016 11:30:10");
  console.log(d2);
  var date = d2.getDate();
  console.log(date);

  方法：
  1、getdate() 获取当前几日
  2、getDay() 获取当前周几 0表示周日 1表示周一...
  3、getMonth() 获取当前月份 0表示1月 11表示12月 所以返回时要+1
  4、getTime() 获取时间戳 1970年1月1日 0时0分0秒 到当前的毫秒数 1s=1000mms

七.获取元素对象
  1、getElementById(): id获取一个元素节点对象
  2、gatElementsByTagName(): 返回一个类数组对象 标签名获取一组元素节点对象//div
  2、getElementsByName(): name属性获取一组元素节点对象

八.querySelector
  document.querySelector()
    需要一个选择器的字符串作为参数 可以根据一个css选择器来查询一个元素节点对象
    var div = document.querySelector(".box1 div");
    选择box1中的第一个div
  document.querySelectorAll()
    所有div

九.事件
  1、事件的冒泡
    冒泡就是事件的向上传导 当后代元素上的事件被触发时 其祖先元素的相同事件也会被触发
    取消冒泡方法：
      将事件对象的cancelBubble设置为true
      event.cancelBubble = true;

  2、事件的委派
    只绑定一次 把事件引用到新加的元素
    将事件统一绑定给共同的祖先元素 这样后代元素的事件触发 会冒泡到祖先元素 通过祖先的响应函数来处理事件
    taget
      event中的taget表示的触发事件的对象
      if(event.taget.className == "元素中的class"){}

  3、事件的绑定
    使用 对象.事件 = 函数 的形式绑定响应函数 只能为一个元素绑定一个函数 绑多了后面会覆盖前面
    addEventListener() 方法可以帮到响应函数
    参数1、事件的字符串 不要on 2、回调函数 3、是否在捕获阶段触发事件 需要一个布尔值 一般为false
    比如：
    btn1.addEventListener("click",function(){
      alert(1);
    },false);
    btn1.addEventListener("click",function(){
      alert(2);
    },false);
    btn1.addEventListener("click",function(){
      alert(3);
    },false);

  4、事件的传播
    微软：事件由内向外传播 应该先触发当前元素上的事件
    网景：由外向内 先触发最外层的祖先元素的事件
    三个阶段
      1、捕获阶段
        在捕获阶段时从最外层的祖先元素 向目标元素进行事件的捕获 默认此时不触发事件
      2、目标阶段
        事件捕获目标元素 捕获结束开始在目标元素上出发事件
      3、冒泡阶段
        事件从目标元素向祖先元素传递 依次触发事件 如果希望在捕获阶段执行 可以将false设为true

十.BOM
  1、Navigator
    代表当前浏览器的信息 通过该对象可以来识别不同的浏览器
    UserAgent
      var 变量 = navigator.userAgent;
  2、History
    代表浏览器的历史记录 可以通过该对象来操作浏览器的历史记录
    由于隐私原因 该对象不能获取到具体的历史记录 只能向前或向后
    back() 
      回退
      history.back();
    forward()
      前进
      history.forward();
    go()
      跳转
      history.go(跳转页面);
  3、Location
    封装了浏览器的地址栏信息
    assign()
      跳转//保留历史
      location.assign("新页面地址");
    reload()
      刷新
      location.reload(true);
    replace()
      替换//无历史记录
      location.replace;

十一.原型与原型链
  原型(prototype)
    每个函数都有一个prototype属性 它默认指向一个object空对象 称为原型对象
    原型对象中有一个属性constructor 它指向函数对象
      函数.prototype.constructor === 函数
    给原型对象添加属性(一般是方法)===>实例对象可以访问
      Fun.prototype.test = function(){
        console.log('test()')
      }
      var fun = new Fun()
      fun.test()//test()

  显式原型和隐式原型//保存相等的地址值
    1、每个函数都有一个prototype 即显式原型(属性) 指向一个空的obj对象
    2、每个实例对象都有一个__proto__ 即隐式原型(属性) 指向
    3、对象的隐式原型的值为其对应构造函数的显式原型的值
      function Fn(){//内部语句：this.prototype = {}}
      var fn = new Fn()//创建实例对象 内部语句：this.__proto__ = Fn.prototype
      console.log(Fn.prototype===fn.__proto__)//true
    4、内存结构图

  原型链
    访问一个对象的属性时
    先在自身属性中找 找到返回
    如果没有 沿着__proto__这条链向上查找 找到返回
    如果都没找到 返回undefined
    别名：隐式原型链
    作用：查找对象的属性（方法）

    构造函数/原型/实体对象的关系(图解)
    1、函数的显式原型指向的对象默认时空的object实例对象
      对Object不满足
    2、所有函数都是Function的实例(包含Function)
    3、Object的原型对象是原型链的尽头

  属性问题
    function Fn(){

    }
    Fn.prototype.a = 'xxx'
    var fn1 = new Fn()
    console.log(fn1.a)

    var fn2 = new Fn()
    fn2.a = 'yyy'
    console.log(fn1.a,fn2.a)//xxx yyy

    1、读取对象的属性时 会自动到原型链中找
    2、设置对象的属性值时 不会查找原型链 如果当前对象中没有此属性 直接添加此属性并设置其值
    3、方法一般定义在原型中 属性一般通过构造函数定义在对象身上

  instanceof
    1、instanceof是如何判断的？
      A实例对象 instanceof B构造函数
      如果B函数的显式原型对象在A对象的原型链上 返回true 否则false      
    2、Function是通过new自己产生的实例

十二.作用域与作用域链
  作用域
  定义了几个函数+1=作用域个数
  1、理解：
    作用域就是一块地盘 一个代码段所在的区域
    他是静态的 相对于上下文 在编写代码时就确定了
  2、分类：
    全局作用域
    函数作用域
  3、作用
    隔离变量 不同作用域下同名变量不会冲突

  作用域链
  由里向外找
  1、理解
    多个上下级关系的作用域形成的链 它的方向是从内到外
    查找变量时就是沿着作用域链来查找的
  2、查找一个变量的查找规则
    在当前作用域下的执行上下文中查找对应的属性 如果有返回 无进入2
    在上一级作用域的执行上下文中查找对应的属性 如果有返回 无进入3
    再次执行2的相同操作 直到全局作用域 如果无就抛出找不到的异常

十三.闭包
监听
  点击某个按钮 提示"点击的是第n个按钮"
  错误：
  var btns = document.getElementsByTagName('button')
  for(var i = 0,length=btns.length ; i < length ; i++){
    var btn = btns[i]
    btn.onclick = function (){
      alert('第'+(i+1)+'个')
    }
  }
  console.log(i)
  正确：
  var btns = document.getElementsByTagName('button')
    for(var i = 0,length=btns.length ; i < length ; i++){
      (function (i){
        var btn = btns[i]
        btn.onclick = function (){
          alert('第'+(i+1)+'个')
        }
      })(i)
  }

理解闭包
  1、如何产生闭包？
    当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时 就产生了闭包
  2、闭包到底是什么？
    理解一：闭包是嵌套的内部函数
    理解二：包含被引用变量(函数)的对象
  3、闭包产生的条件
    函数嵌套
    内部函数引用了外部函数的数据(变量/函数)

常见的闭包
  1、将函数作为另一个函数的返回值
  function fn1() {
    var a = 2
    function fn2() {
      a++
      console.log(a)
    }
    return fn2
  }
  var f = fn1()
  f()//3
  f()//4
  2、将函数作为实参传递给另一个函数调用
  function showDelay(msg,time){
    setTimeout(function(){
      alert(msg)
    },time)
  }
  showDelay('atguigu',2000)//atguigu

闭包的作用
  1、使用函数内部的变量在函数执行完后 仍然存活在内存中(延长了局部变量的生命周期)
  2、让函数外部可以操作到函数内部的数据
  问题：
    1、函数执行完后 函数内部声明的局部变量是否还存在？一般是不存在 存在于闭包中的变量才可能存在
    2、在函数外部能直接访问函数内部的局部变量吗？不能 但是可以通过闭包让外部操作它

闭包的生命周期
  1、产生：在嵌套内部函数定义执行完时就产生了(不是再调用)
  2、死亡：在嵌套的内部函数成为垃圾对象时(f = null)

闭包的缺点
  1、缺点：函数执行完后 函数内的局部变量没有释放 占用内存时间会变长 容易造成内存泄漏
  2、内存溢出：
    一种程序运行出现的错误
    当程序运行需要的内存超过了剩余的内存时 就会抛出内存溢出的错误
    var obj = {}
    for(var i = 0 ; i < 10000 ; i++){
      obj[i] = new Array(1000000)
      console.log('---------')
    }
  3、内存泄漏
    占用的内存没有及时释放
    内存泄漏积累多了就容易导致内容溢出
    常见的内容泄露
      意外的全局变量
      没有及时清理的计时器或回调函数
      闭包

十四.声明变量
  let
  1、变量不能重复声明
      let star = 's'
      let star = 'a'
  2、块级作用域
      if else while for 都是块
  3、不存在变量提升
  4、不影响作用域链
  const
  1、定义常量 值不能修改 一定要赋初始值
  2、一般的常量使用大写
  3、块级作用域
  4、对于数组和对象的元素修改 不算常量 不报错

十五.模板字符串
  1、声明
    let str = `sjhajhbkj`
  2、内容中可以直接出现换行符
    let str = `<ul>
                <li>shenteng</li>
                <li>mali</li>
                </ul>`
  3、变量拼接
    let lovest = `a`
    let out = `${lovest}b`
    console.log(out)//ab

十六.箭头函数
  1、声明一个函数
    let fn = function(){

    }
    ↓
    let fn = () => {

    }
  2、调用函数
    fn()
  3、特点：
    this是静态的 始终指向函数声明时所在作用域下的 this 的值
    function getName(){
      console.log(this.name)
    }
    let getName2 = () => {
      console.log(this.name)
    }

    //设置 window 对象的 name 属性
    window.name = 'shangguigu'
    const school = {
      name:"ABU"
    }
    getName()//shangguigu
    getName2()//shangguigu

    //call方法调用
    getName.call(school)//ABU
    getName2.call(school)//shangguigu
  4、不能作为构造实例化对象
    let Person = (name,age) => {
      this.name = name
      this.age = gae
    }
    let me = new Person('xiao',30)
    console.log(me)//报错
    5、不能使用 arguments 变量
    6、简写：
    省略小括号：当形参有且只有一个
    省略花括号：当代码体只有一条语句 return也必须省略
      let pow = (n) => n*n
      console.log(pow(8))//64

    定时器：setTimeout(回调函数,倒计时毫秒)
    箭头函数适合于 this 无关的回调 定时器 数组的方法回调
    不适合与 this 有关的回调 事件回调 对象的方法

十七.symbol
特点：
  1、Symbol 的值是唯一的 用来解决命名冲突的问题
  2、Symbol 值不能与其他数据进行运算
  3、Symbol 定义的对象属性不能使用 for in 循环遍历 但是可以 Reflect.ownKeys 来获取对象的所有键名
如何创建？
  let s = Symbol()
  console.log(s, typeof s)//Symbol
  let s2 = Symbol('shangguigu')
  let s3 = Symbol('shangguigu')
  console.log(s2===s3)//false

  let s4 = Symbol.for('shangguigu')
  console.log(s4, typeof s4)//Symbol
不能与其他数据进行运算(对比/拼接)
如何使用？
  向对象中添加方法 up down
  let game = {...
    //声明对象
    up:Symbol(),
    down:Symbol()
  }
  game[menthods.up] = function(){
    console.log("我可以改变形状")
  }
  game[methods.dowm] = function(){
    console.log("我可以快速下降")
  }
  console.log(game)

  let youxi = {
    name:"狼人杀",
    [Symbol('say')]:function(){
        console.log("我可以发言")
    },
    [Symbol('zibao')]:function(){
        console.log('我可以自爆')
    }
  }
  console.log(youxi)

十八.迭代器
是一种接口 为不同的数据结构提供统一的访问机制
原生具备 iterator 接口的数据
  声明一个数组
  const xiyou = ['唐僧','孙悟空','猪八戒','沙僧']
  使用 for...of 遍历数组
  for(let v of xiyou){//for in保存键名 for of保存键值
      console.log(v)
  }
工作原理
  1、创建一个指针对象 指向当前数据结构的起始位置
  2、第一次调用对象的 next 方法 指针自动指向数据结构的第一个成员
  3、接下来不断调用 nest 方法 指针一直往后移动 直到指向最后一个成员
  4、每调用 next 方法返回一个包含 value 和 done 属性的对象
应用
  //声明一个对象
  const banji = {
    name:"终极一班",
    stus:[
        'xiaoming',
        'xiaoning',
        'xiaotian',
        'knight'
    ]
  [Symbol.iterator](){
    //索引变量
    let index = 0
    return{
      next:function(){
        if(index < this.stus.length){
            return{value:_this.stus[index],done:false}
            //下标自增
            index++
            //返回结果
            return result
          }else{
            return{value:undefined,done,true}
          }
        }
      }
    }
  }
  //遍历这个对象
  for(let v of banji){
      console.log(v)
  }

十九.生成器
  生成器是一个特殊的函数
  异步编程 纯回调函数
  yield 函数代码分隔符
  function * gen(){
      console.log("ad")
  }
  let iterator = gen()
  iteratir.next()//ad

  function * gen(){
      console.log(1)
      yield 'a'
      console.log(2)
      yield 'b'
      console.log(3)
      yield 'c'
      console.log(4)
  }
  let iterator = gen()
  iteratir.next()//1
  iteratir.next()//2
  iteratir.next()//3
  iteratir.next()//4

  遍历
  for(let v of gen()){
      console.log(v)//a b c
  }

  console.log(iteratir.next())//{value:"a",done:false}
  console.log(iteratir.next())//{value:"b",done:false}
  console.log(iteratir.next())//{value:"c",done:false}
  console.log(iteratir.next())//{value:undefined,done:true}

  生成器的函数参数
  gen('AAA')//AAA 如果有输出就会输出这个参数
  next方法传入实参 next('BBB') 第二次next参数作为第一个yield语句的返回结果

二十.promise
  异步编程的解决方案 是一个构造函数封装异步操作
  //实例化Promise对象
  const p = new Promise(function(resolve,reject){
      setTimaout(function(){
          //resolve
          let data = '数据库中的用户数据'
          resolve(data)
          //let err = '数据读取失败'
          //reject(err)
      },1000)
  })
  //调用 Promise 对象的 then 方法
  p.then(function(value){
      console.log(value)//数据库中的用户数据
  },function(reason){
      consolo.error(reason)

  })

  读取文件内容
  1、引入 fs 模块
  2、调用方法读取文件
  3、使用 Promise 封装
      const P = new Promise(function(resolve,reject){

      })

  then方法
  //创建 Promise 对象
      const P = new Promise((resolve,reject) => {
          setTimeout(()=>{
              resoleve('用户数据')
          },1000)
      })
  //调用then方法 返回结果是 Promise 对象 对象状态由回调函数的执行结果决定
      const result = p.then(value => {
          console.log(value)
      },reason => {
          console.log.warn(reason)
      })
      console.log(result)
*VUE*
一.v-once
  <h2 v-once>{{message}}</h2>
  <!-- 元素和组件只渲染一次 不会随数据的改变而改变 -->
二.v-html
  <h2>{{url}}</h2>不打开url
  <h2 v-html="url"></h2>打开url
三.v-test
  <h2>{{message}},李银河！</h2>显示message
  <h2 v-test="message"> ,李银河！</h2>不显示message
四.v-pre
  <h2 v-pre>{{message}}</h2>
  <!-- 跳过编译过程 -->
五.v-bind
  <img v-bind:src="imgURL" alt="">
  <!-- v-bind用于绑定一个或多个属性值,或者向另一个组件传递props值 -->
六.v-for
  <li v-for="(m,index) in movies">{{index}} {{m}}</li>
七.
  const app = new Vue ({
    el: '#app',
    data: {

    },
    computed: {

    }
    methods: {

    }
  })
八.computed的set和get
九.v-on
  监听
十.v-if
十一.v-show
十二.v-model
  双向绑定
  <div id="app">
  <!-- 1.修饰符: lazy -->
  <input type="text" v-model.lazy="message">
  <!-- 写完后敲回车才绑定到message -->
  <h2>{{message}}</h2>
  <!-- 2.修饰符: number -->
  <input type="number" v-model.number="age">
  <h2>{{age}} {{typeof age}}</h2>
  <!-- 3.修饰符: trim -->
  <input type="text" v-model.trim="name">
  <!-- 自动去除前面的空格 -->
  <h2>{{name}}</h2>
十三.路由
1.index.js文件
  -配置路由: const Home = () => import('../components/Home')
  -安装路由功能: Vue.use(VueRouter)
  -创建VueRouiter对象: const routes=[{},{},...]
  -路由对象的属性: path component meta{title} children:[{}.{},...]
  -配置路由和组件间的关系: const router=new VueRouter({routes,mode:'history',linkActiveClass:'active'})
  -将router对象传到vue实例: export default router
  -重定向: path:'',redirect:'/home'
  -导航守卫
  //前置守卫guard
  router.beforeEach((to, from, next) => {
  //从from跳转到to
  document.title = to.matched[0].meta.title
  console.log(to);
  next()
  })
  //后置钩子hook
  router.afterEach((to, from) => {
    console.log('.....')
  })

2.vue文件
  1.template
  -导入路由: <router-link to="/home">首页</router-link>
  -预定位置: <router-view></router-view>
  2.script:export default {}
  -name:
  -data(){return{}}
  -computed:{}
  -methods:{}
3.this.$router
  -push({path,query})新页面
  -replace()
4.传递参数
  1.params
  -配置路由格式: /router/:id
  -传递的方式: 在path后面跟上对应的值(paramas.abc)
  -传递后形成的路径: /router/123,/router/abc
  2.query
  -配置路由格式: /router
  -传递的方式: 对象中使用query的key作为传递方式
  -传递后形成的路径: /router?id=123,/router?id=abc
十四.vuex
1.index.js文件
  import Vue from 'vue'
  import Vuex from 'vuex'
  //安装插件
  Vue.use(Vuex)
  //创建对象
  const store = new Vuex.Store({五个对象})
  //导出store独享
  export default store
2.main.js文件
  import store from './store'
  new Vue增加store
3.App.vue文件
  引入counter: {{$store.state.counter}}
  export deffault增加: components:{HellowVuex}
  在methods中引入mutations方法: 函数名(){this.$store.commit('方法名')}
  拿到并展示getters方法: {{$store.getters.方法名}}
4.HellowVuex.vue文件
  引入counter: {{$store.state.counter}}
  export deffault中name:"HellowVuex"
5.五个对象
  state
  mutations
  actions
  getters
  mudules
十五.封装axios
1.request.js文件
  import axios from "axios";
  import { startLoading, endLoading } from "../common/Loading";
  export function request(config) {
    const instance = axios.create({
      baseURL: "/api",
      timeout: 30000,
      withCredentials: true,
    });
    // 请求拦截
    instance.interceptors.request.use(
      config => {
        if (config.url != "/login/qr/check") {
          startLoading();
        }
        return config;
      },
      error => {
        return Promise.reject(error);
      }
    );
    // 响应拦截
    instance.interceptors.response.use(
      response => {
        endLoading();
        return response;
      },
      error => {
        endLoading();
        return Promise.reject(error);
      }
    );
    instance.defaults.withCredentials = true;
    return instance(config);
  }
2.其他文件
  import {request} from '../request'
  export function getHotComment(参1,参2){
      return request({
          url:'/comment/hot',
          params:{
              参1,
              参2,
              limit:
          }
      })
  }